1.值传递和引用传递
    方法在传参数的过程中，传递的是值、引用
    
    如果方法的参数 传递的数据类型为基本数据类型时 为值传递
		   值传递 不会影响传递的参数变量值
		  传递的数据类型为引用类型时
		   在方法内修改值，则传递的参数也会发生变化


复习
1.面向对象
  什么是类？具有共通属性和功能的一类事物的抽象
  类和对象的关系：类是对象模板 对象是类的实例化
  面向对象的特点：封装 继承 多态
2.构造方法：
  什么是构造方法：在类实例化对象过程中调用的方法
  规则：  没有返回值类型  方法名和类名相同 ，可以重载
3.this关键字：
  this 指代当前、这个对象（this所在的方法被那个对象调用 则为哪个对象）
  场景：区分属性和参数时使用
4.static关键字：
  静态的  修饰符
  修饰 成员变量
	   作用域相对类存在，所有当前类对象共用一个静态成员
	   调用：类名.变量名(同一类中类名可略)
       方法
	   作用域相对类存在，
	   调用：类名.方法名(同一类中类名可略)
	   注意：在该方法中不能直接使用非静态成员(需要先实例化对象 再点语法调用)
       代码块
	   作用域相对类存在，
	   调用：在类加载时   自动调用(加载类后只调用一次，再次加载类不进行调用)
	   场景：需要给静态成员赋初始值，初始化功能
5.类中变量、方法的调用方式
  变量：静态变量   类名.变量名
	非静态     对象名.变量名
  方法：静态方法   类名.方法名
	非静态方法 对象名.方法名
  构造方法:实例化过程手动调用
  代码块：静态代码块  加载类自动
	  非静态代码块  实例化自动
  顺序：静态代码块  非静态代码块 构造方法  实体方法
6.访问权限修饰符：
  public（公有权限） 
  protected（受保护的 保护的是朋友和子女：同包、继承关系） 
  default（友好的 在同一包内可访问） 
  private （私有的 只有当前类本身可用）

  类 public  default ，建议使用public
  变量 public、protected、default、private ，建议成员变量使用private修饰 
  方法 public、protected、default、private，建议普通方法使用public修饰

7.访问器方法
  如果成员被private修饰，且需要类本身提供访问入口时，需要访问器方法
  访问器方法：get方法+set方法
      get方法：public 属性数据类型 get属性名(){
		return 属性名;
	       } 
      set方法：public void set属性名(属性数据类型 属性名){
			this.属性名 = 属性名;
		}
8.方法的重载
  场景：不同数量、类型的参数 需要实现同一个功能时， 需要使用方法的重载
  规则：方法名相同  参数列表不同
  调用：根据调用方法时 传参不同 自动匹配相应的方法
9.数组：
  存放相同数据类型的多个元素的容器
  数组的长度一旦确定不可修改
  定义：静态赋值   动态赋值
	int[] a = {1,2,3}
	int[] a = new int[3]; a[0] = 1;
  取值、改值：通过元素所在的位置进行值的访问
	      元素的位置称为下标
	      ！！下标从0开始 到length-1为止
  数组排序：
	冒泡算法：循环元素个数次，每循环一次相邻元素两两比较，根据排序条件互换位置
        系统提供 Arrays.sort(数组名) 底层提供升序方法
  数组复制：
	错误做法：int[] a = {1,2,3}; int[] b = a;
	正确做法：
		for(int i=0;i<a.length;i++){
			b[i] = a[i];
		}

		System.arrayCopy(a,0,b,0,a.length);
  数组中元素的默认值：
	数值类型：0 0.0
	字符类型：占位符、空格
	布尔类型：false
	引用类型：null
10.异常：
	NullPointerException
	InputMismatchException
	ArrayIndexOutOfBoundsException
	ClassCastException
11.方法定义的规范

   访问修饰符 返回值类型 方法名(参数列表){
	代码行;
   }
   方法的通用规范：
	方法尽量减少和方法外的关联
	写方法时将功能完成后，方法体收起来
	调用时 只看方法声明的第一行
   方法的递归调用（不死神兔）：
	递归调用的方法一定需要出口，不然就是死循环
	
  




